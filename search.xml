<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[0 x 0D]]></title>
    <url>%2F2017%2F07%2F24%2F0x0D%2F</url>
    <content type="text"><![CDATA[Summer Training Day 14. 休息日. 真没有内容..弄成折叠的没别的意思,只是相关统计以及评论系统无法在主页加载. 以上.]]></content>
  </entry>
  <entry>
    <title><![CDATA[0x0C]]></title>
    <url>%2F2017%2F07%2F22%2F0x0C%2F</url>
    <content type="text"><![CDATA[Summer Training Day 13. LiveRe 今天早上照例是产品大会.进一步商讨了方案.我针对自己博客的评论系统问题做出了一些改动.之前提到过youyan(友言)评论系统因为没有https证书所以会被浏览器block，要点击右上角加载不安全版本才能正常显示，但是这样就显得我的博客不干不净一样.于是乎，在今天，我决定把它ban掉.直接换一个评论系统.我认准了来必力(LiveRe),一个外国做的评论系统.这个系统有https证书，可以在博客直接加载.而且新版next兼容了livere可以像youyan一样直接输个UID就能用,非常非常方便.以下是教程: 百度livere，进入官网，可以设置语言为中文，方便操作.点击右上角注册，一步一步填写关于你个人网页的信息，设置评论推送，显示分页方式等等.之后就会输出一串js代码：获取如图所示的一串UID，复制到 next 主题配置文件(/theme/next/_config.yml)中的对应位置即可.真的是非常非常简单！另外可以看到，上官网个人信息可以管理自己博客的评论，查看等等..实在是太强大了. 以上.]]></content>
  </entry>
  <entry>
    <title><![CDATA[0x0B]]></title>
    <url>%2F2017%2F07%2F21%2F0x0B%2F</url>
    <content type="text"><![CDATA[Summer Training Day 12. apply&amp;call&amp;bind.json call&amp;apply&amp;bind apply()12345678var x = 0;function test()&#123; alert(this.x);&#125;var o=&#123;&#125;;o.x = 1;o.m = test;o.m.apply(); //0 apply()和call()12function.apply(thisArg, [argsArray])thisArg //传入function内this的值(可以改变this指向thisArg) “thisArg在 fun 函数运行时指定的 this 值。需要注意的是，指定的 this 值并不一定是该函数执行时真正的 this 值，如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动指向全局对象（浏览器中就是window对象），同时值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的自动包装对象。argsArray一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 fun 函数。如果该参数的值为null 或 undefined，则表示不需要传入任何参数。”以上为MDN的解释.其实就是改变this指向，从原来的改为指向thisArg.call和apply类似，不同点在于call第二项需要直接传递给函数，即一项一项写出来，apply可以以一个数组形式写出来. bind()bind会创建一个函数的实例，this值会绑定到传给bind()函数的值.本质上同apply&amp;call但是需要赋给变量. json(Javascript Object Notation.)是一种数据格式而非语言. 语法.可以表示以下三种类型的值. 简单值数字，字符串，布尔值，null(字符串必须使用双引号) 对象JSON无变量，没有变量的概念，所以没有声明变量这一步骤,语句结束也无分号.如：12345678&#123; "name": "Nicolas", "age": 29, "school": &#123; "name": "Merrimack College", "location": "North Andover, MA" &#125;&#125; json中不能写注释. 数组123456789101112131415161718[ &#123; "title": "Professional JavaScript", "authors": [ "Nicolas C. Zakas" ], "edition": 3, "year": 2011 &#125;, &#123; "title": "Professional JavaScript", "authors": [ "Nicolas C. Zakas" ], "edition": 2, "year": 2009 &#125;,] 解析与序列化选项.stringify() 与 parse()前者转化为JSON字符串，后者解析.前者输出的JSON不包含任何空格字符或缩进，因此保存在jsontext中的字符串显示如下：1&#123;"title": "Professional JavaScript","authors": ["Nicolas C. Zakas"],"edition": 3,"year": 2011&#125; 所有函数及原型成员都会被有意忽略，值为undefined的任何属性也会被跳过. 序列化选项第二个参数： 函数1var jsontext = JSON.stringify(book,["title","edition"]); 第三个参数： 缩进和空白符1var jsontext = JSON.stringify(book,null,4); 换行符自动包含，缩进空格数为4;也可以变成：1var jsontext = JSON.stringify(book,null,"--"); 缩进字符串最长不能超过10个，若超过了只显示前10个.可以在js任意对象中添加toJSON()方法，作为函数过滤器的补充.stringify()顺序：1.如果存在toJSON()方法且能通过它取得有效值，则调用该方法，否则返回对象.2.如果提供了第二个参数，应用改函数过滤器.传入函数过滤器的值是第一步返回的值.3.对第2步返回的值进行相应序列化.4.若提供了第三个参数,执行相应格式化. Ajax待续.. 以上.]]></content>
  </entry>
  <entry>
    <title><![CDATA[0x0A]]></title>
    <url>%2F2017%2F07%2F21%2F0x0A%2F</url>
    <content type="text"><![CDATA[Summer Training Day 11. 画钟this clockummmmm..没什么可说的，css设置好html,body，canvas位置关系之后，剩下的就是js.先画底圆，然后刻度，然后秒分时针，最后中间点.计时器setIinterval(function,1000);1秒一次，内部先clear再draw.一开始先draw一次让网页刷新就有东西.具体实现利用了许多数学的东西,简单但麻烦.强烈推荐colorhunt配色网站以及Webgradients渐变色网站 thisthis的四种用法： 直接调用.this指向全局对象.12345 var x = 1; function test()&#123; consloe.log(this.x); &#125; test(); // 1(非严格模式下) this.x就是window.x.改一改：123456 var x = 1; function test()&#123; this.x = 0; &#125; test(); console.log(x); //0,改了全局x. 高难度直接调用：123456789101112var name = "the window";var object = &#123; name : "my object", getNameFunc : function()&#123; return function()&#123; return this.name; &#125;; &#125;&#125;; console.log(object.getNameFunc()()); //"the window"(非严格模式下) 第一个return返回的是函数，即object.getNameFunc()接收的是一个匿名函数( 记object.getNameFunc()为a )，第二个括号a()相当于直接调用.a()里面的this当然是指向全局.若要访问object内部的name.12345678910111213var name = "the window";var object = &#123; name : "my object", getNameFunc : function()&#123; var that = this; //此时this指向object return function()&#123;//这个return匿名函数是全局调用的，但是里面是之前保存的that不是this，故输出my object. return that.name; &#125;; &#125;&#125;; //另外，在构建闭包(匿名函数)全局调用getNameFunc的时候访问了内部变量that，此时that仍然引用着object.console.log(object.getNameFunc()()); //"my object" 或者更简单地：123456789101112var name = "the window";var object = &#123; name : "my object", getNameFunc : function()&#123; return this.name;//毫无悬念地指向object &#125;&#125;; console.log(object.getNameFunc()); //"my object"(object.getNameFunc = object.getNameFunc)(); //"the window"//为什么这里又输出the window？原因是这是赋值表达式，赋值后是函数本身，相当于a()，全局调用. 方法调用.作为对象方法调用.12345678function test()&#123; console.log(this.x);&#125;var o = &#123;&#125;;o.x = 1;o.m = test;o.m(); // 1//这里m变成test方法. call,apply,bind显而易见地改变了this的值指向新值. new使用new的具体步骤中有改变this指向空对象这一步. 以上.]]></content>
  </entry>
  <entry>
    <title><![CDATA[0x09]]></title>
    <url>%2F2017%2F07%2F19%2F0x09%2F</url>
    <content type="text"><![CDATA[Summer Training Day 10.构造函数与原型.继承.今天补充前两天的内容. 构造函数与原型构造函数模式.1234567891011//构造函数默认以大写字母开头.function Person(name, age)&#123; this.name = name; this.age = age; this.sayName = function()&#123; alert(this.name); &#125;;&#125;var person1 = new Person("Nicolas",29);var person2 = new Person("John",18);//可以说，使用new操作符来创建新对象的函数就可以作为构造函数. 要创建新实例，则必须使用new操作符.new做了5件事情：1.创建新对象.2.this指向这个新对象(通过把构造函数的作用域赋于新对象).3.连接原型链.4.执行函数(也是在给新对象添加属性).5.返回新对象.(Object与Array为原生构造函数) 纯构造函数的缺点.每个方法要在每个实例上创建一遍，因此，不同实例上的同名函数其实是不相等的.与其在构造函数内部定义函数，还不如在外部定义，这样每个实例共享一个函数，但是这样做又有问题.在全局作用域定义函数但是只是让某个对象使用就有点浪费，而且可能需要为此定义许多全局函数.这个自定义引用类型就毫无封装性可言了.以上问题可以通过原型模式解决. 原型模式.每个函数都有一个prototype(原型)属性，该属性为一个指针指向一个对象(原型对象)，这个对象包含特定类型所有实例共享的属性和方法.使用原型对象可以让所有实例共享它所包含的属性和方法.就不必要在构造函数中定义.123456789101112131415function Person()&#123;&#125;Person.prototype.name = "Nicolas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function()&#123; console.log(this.name);&#125;;var person1 = new Person();person1.sayName(); //"Nicolas"var person2 = new Person();person2.sayName(); //"Nicolas"console.log(person1.sayName === person2.sayName); //True 默认情况下，所有原型对象会自动获得一个constructor(构造函数)属性.此属性为一个指向prototype属性所在函数(即构造函数)的指针.即：Person.prototype.constructor = Person;创建了构造函数后，其原型对象默认只会取得constructor属性，其他属性继承Object;创建新实例后，该实例内部包含一个指针(内部属性)__proto__,指向构造函数的原型对象,该属性对脚本完全不可视.[需要注意的是，此关系(Person与Person.prototype)存在于构造函数与其原型对象之间，而与实例无关(即person1无prototype属性只有看不见的__proto__)].但是实例对象共享constructor属性(可能是因为__proto__属性吧).person1.constructor == Person.虽然__proto__属性无法访问，但的确是可以通过 isPrototypeOf() 方法来确定这个关系.若__proto__指向Person.prototype，则会返回True.12console.log(Person.prototype.isPrototypeOf(person1)); //Trueconsole.log(Person.prototype.isPrototypeOf(person2)); //True 也可以通过Object.getPrototypeOf()方法返回__proto__的值.12console.log(Object.getPrototypeOf(person1) == Person.prototype); //Trueconsole.log(Object.getPrototypeOf(person1).name); //"Nicolas" 每当代码读取某个对象的某个属性时，都会执行一次搜索.首先从实例开始,如果没找到,则继续搜索其指针指向的原型对象.有的话就返回其属性值.也就是说，当我们调用person1.sayName()时，会先后进行两次搜索.如果在实例找到就不会往上找.这样就引出了在实例不能重写原型属性，但在属性同名的情况下会屏蔽原型属性的问题.12345678910111213141516function Person()&#123;&#125;Person.prototype.name = "Nicolas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function()&#123; console.log(this.name);&#125;;var person1 = new Person();var person2 = new Person();person1.name = "Greg"; //此操作相当于在实例中新建name属性并且屏蔽Person.prototype中的name.console.log(person1.name); //"Greg"console.log(person2.name); //"Nicolas" 即便 person1.name = “”; 也不能恢复对原型Person.name的链接.要想恢复连接，就要用到delete操作符.1delete person1.name; hasOwnProperty()方法可以检测一个属性是在原型中还是实例中123456789101112131415161718function Person()&#123;&#125;Person.prototype.name = "Nicolas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function()&#123; console.log(this.name);&#125;;var person1 = new Person();var person2 = new Person();console.log(person1.hasOwnProperty("name")); //falseperson1.name = "Greg";console.log(person1.name); //Greg————来自实例console.log(person1.hasOwnProperty("name")); //true Object.getOwnPropertyDescriptor( object , propertyname )方法只能用于实例属性信息获取.1234console.log(Object.getOwnPropertyDescriptor(person1,"name"));//Object &#123;value: "Greg", writable: true, enumerable: true, configurable: true&#125;console.log(Object.getOwnPropertyDescriptor(person2,"name"));//undefined.因为person2中未创建name属性.原型的属性它不会找. in操作符单独使用时，会在能够访问给定属性时返回true，无论该属性存在于原型中还是实例中.1console.log("name" in person1); //true Object.keys()方法获取对象上所有可枚举的实例属性.1234567var keys = Object.keys(Person.prototype);console.log(keys); //"name,age,job,sayName"var p1 = new Person();p1.name = "Rob";p1.age = 31;var p1keys = Object.keys(p1);console.log(p1keys); //"name,age" 定义原型对象属性的简便写法：123456789function Person ()&#123;&#125;Person.prototype = &#123; name : "Nicolas", age : 29, job : "Software Engineer", sayName : function()&#123; console.log(this.name); &#125;&#125;;//注意冒号和逗号 此方法有个缺陷，就是constructor不再指向Person而是Object(本质上改写了整个prototype),要指回来需要在花括号里面加上”constructor : Person”:12345678910function Person ()&#123;&#125;Person.prototype = &#123; constructor : Person name : "Nicolas", age : 29, job : "Software Engineer", sayName : function()&#123; console.log(this.name); &#125;&#125;; 但是这样做又有一个问题，就是其[[Enumerable]]属性被设置为true,即 可枚举.若不想让constructor可枚举，则可以换一种添加方法.Object.defineProperty(object,property,descriptor)1234Object.defineProperty(Person.prototype,"constructor",&#123; enumerable : false, value : Person&#125;); 继承原型链本质上是把父类型的实例赋予子类型的原型对象.重写原型对象，代之以一个新类型的实例.12345678910111213141516171819function SuperType () &#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function()&#123; return this.property;&#125;function SubType()&#123; this.subproperty = false;&#125;//继承 SuperTypeSubType.prototype = new SuperType();SubType.prototype.getSubValue = function()&#123; return this.subproperty;&#125;;var instance = new SubType();console.log(instance.getSuperValue()); //true 相关继承方式(原型式，寄生式，寄生组合式)以后再议… 以上抄书.]]></content>
  </entry>
  <entry>
    <title><![CDATA[0x08]]></title>
    <url>%2F2017%2F07%2F18%2F0x08%2F</url>
    <content type="text"><![CDATA[Summer Training Day 9. 引用类型 引用类型 Object类型创建方法：123//new操作符法.var person = new Object(); &lt;=&gt; var person = &#123;&#125;;//Object()为构造函数. 12345678910111213//对象字面量法var person = &#123; name : "John", age : 30&#125;;//其中大括号表示对象字面量的开始，出现在表达式上下文中，//表示一个表达式的开始.如果出现在语句上下文就表示语句的开始.//其中属性名也可以用引号引起来，但是这样会导致其他数值也会自动转成字符串.var person = &#123; "name" : "John", "age" : 30 5 : true//这里的5会转换成字符串&#125;; 12345678910//点表示法.（一般方法）person.nameperson.age//方括号表示法.alert (person["name"]);//可以通过变量访问属性.var propertyName = "name";//这里把属性赋给变量alert (person[propertyName]);//John//另外，在一些情况下不得不用方括号.person["first name"] = "John"//这里有空格用点表示会有歧义. Array类型创建方法：1234var colors = new Array(); &lt;=&gt; var colors = [];var colors = new Array(20);//length = 20;var colors = new Array("grey");//值为grey.var colors = new Array("grey","red","blue"); 数组的length属性不是只读的，可以移除或新增项.1234567var color = ["grey","red","blue"];color.length = 2;//blue被删除.color.length = 4;alert(color[3]);//undefined.//还可以实现类似push的功能.var color = ["grey","red","blue"];colors[colors.length] = "black";//末尾新增black. p.s.数组最多可以包含4 294 967 295项.检测数组：1234567var colors = [];colors instanceOf Array;//True.//但是instanceOf有缺陷，它假定只有一个全局执行环境.//当网页有多个框架时就会有多个不同的全局执行环境.//为了解决这个问题，ES5新增了Array.isArray(value)方法.Array.isArray(colors);//True.//此方法不管value在哪里创建的，就返回value是不是数组. 一些方法.栈方法.LIFO后进先出 push()&amp;pop();12345678var colors = [];//创建数组var count = colors.push("red","white");//推入两项alert(count);//2var count = colors.push("black");//推入另一项var item = colors.pop();//弹出最后一项并取之.alert(item);//"black"alert(colors.length);//2 队列方法.FIFO先进先出 push()&amp;shift()&amp;unshift();12345678var colors = [];//创建数组var count = colors.push("red","white");//推入两项alert(count);//2var count = colors.push("black");//推入另一项var item = colors.shift();//弹出第一项并取之.alert(item);//"red"alert(colors.length);//2 12//与shift()相反的unshift()即是在第一项前面添加新项.//unshift也与push对应. 操作方法. concat() 123456789//concat.var colors = ["red","green","blue"];var colors2 = colors.concat("yellow",["black","brown"]);alert(color)//red,green,bluealert(color2)//red,green,blue,yellow,black,brown//若concat()无参数则只是复制当前数组并返回副本//若有一个或多个一维数组，则将它们每一项都添加进副本返回.//数组嵌套(n维数组)的情况，内层的作为一个n-1维数组返回.//若就一个数组则正常添加并返回. slice() 12345678910111213var colors = ["red","green","blue","yellow","purple"];var colors2 = colors.slice(1);var colors3 = colors.slice(1,4);//若只有一个参数则返回从指定参数开始到数组末尾所有项.//若两个参数则返回起始位置到终止位置所有项但不包含终止位置项(左闭右开)"[ , )"alert(colors2);//green,blue,yellow,purplealert(colors3);//green,blue,yellow//当第二个参数为负数时，情况又有所不同.var colors4 = colors.slice(1,-1);//应该输出green,blue,yellow//负数是从右边数起的，正确理解应该是 -1 + 5 = 4// 负值 + arr.length//即colors.slice(1,-1); &lt;=&gt; colors.slice(1,4); p.s.若起始位置大于终止位置(负值除外)，则返回空数组。 spilce()据《JavaScript高级程序设计(第三版)》一书，splice()方法”算是最强大的数组方法”12345Array.splice(position,deleteNumber,addThings);position//表示操作点位置.这个位置指向的是两个相邻项之间的空隙.deleteNumber//表示从操作点位置开始删除项的个数.addThings//表示从操作点开始插入的新项.该方法返回的是被删除的数组,若没有删除则返回空数组. 如：123456789101112var colors = ["red","green","blue"];var removed = colors.splice(0,1);//从0位置开始删一项redalert(colors);//green,bluealert(removed);//redvar removed = colors.splice(1,0,"yellow","orange");//从1位置开始不删除并插入两新项alert(colors);//green,yellow,orange,bluealert(removed);//空var removed = colors.splice(1,1,"red","purple");//从1位置开始删除yellow并插入两新项alert(colors);//green,red,purple,orange,bluealert(removed);//yellow 现在看来果不其然.. 迭代方法.以下方法均为对数组，每一项执行给定的函数.且均不会改变原数组的值. every(): 若每一项都返回True，则返回True. some(): 任意一项返回True,则返回True. filter(): 返回所有返回True的项构成的数组. forEach(): 无返回值. map(): 返回每次函数调用的结果构成的数组. 格式(以forEach为例)：123num.forEach(function(item,index.array)&#123; //操作.&#125;); 归并方法. reduce()&amp;reduceRight()12345678//reduce()从第一项开始逐项遍历到最后.//reduceRight()从最后一项开始遍历.//两者都是返回一个数值.格式:var values = [1,2,3,4,5];var sum = values.reduce(function(accumulate,current,index,array)&#123; return accumulate + current;&#125;); Date类型1234var now = new Date();console.log(date);//当前时间;getHours();//Minutes,Seconds,Month,FullYearsetHours(); 以上.]]></content>
  </entry>
  <entry>
    <title><![CDATA[0x07]]></title>
    <url>%2F2017%2F07%2F17%2F0x07%2F</url>
    <content type="text"><![CDATA[Summer Training Day 8. IFE Task 15异步，作用域与闭包第二周的第一天. IFE Task. Task 15.;12345innerText//除去html标签外的内容.split//split("",num)方法用于把一个字符串分割成字符串数组.左参数为分割标准，右参数为长度(可选).childnodes//我们平时用document.getElementById("")获取的是元素节点，非文本节点，childnodes获取的即是元素节点的子节点(包括文本).nodeValue//获取节点值push//push方法在数组末尾添加一个或多个元素，并返回新长度(注意是长度数值而非返回新数组). 12345getData();//获取sort();//排序render();//显示btnhandle();//绑定按钮init();//执行 最后加一句防止按钮重复点击：1if(resort.innerText == "") 异步、作用域与闭包. 执行环境与作用域1.执行环境(execution context,简称环境)，每个环境都有与之对应的一个变量对象(variable object)，包含在环境中定义的所有变量和函数。全局执行环境，是最外围的执行环境，在Web中被认为是windows对象。某个执行环境中的代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁，但在全局执行环境的直到应用程序退出才会被销毁。2.每个函数都有自己的执行环境，当执行流进入一个函数，函数的环境会被推入一个环境栈中，执行完之后栈将其环境弹出，把控制权交还给之前的执行环境。3.当代码在一个环境中执行时，会创建变量对象的一个作用域链(scope chain)。其前端始终是当前执行的代码所在环境的变量对象。如果是函数，则其活动对象(activation object)为变量对象。活动对象最开始时只包含argument对象(此对象在全局是不存在的)，全局执行环境的变量始终是作用域链的最后一个对象。(摘自JavaScript高级程序设计) 闭包定义：闭包是指有权访问另一个函数作用域中的变量的函数。在函数内部创建另一个函数就是一种创建闭包。攻略↓Excuse me？这个前端88面试在搞事！汤姆大叔的博客:”深入理解JavaScript系列（16）：闭包（Closures）”所以，不只是setTimeout的问题. 12345for (var i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 1000 * i);&#125; //输出5个5 与 1234567891011var data = [];for (var k = 0; k &lt; 3; k++) &#123; data[k] = function () &#123; alert(k); &#125;;&#125;data[0](); // 3, 而不是0data[1](); // 3, 而不是1data[2](); // 3, 而不是2//上下文共用一个[[scope]]属性，故k改变 解决方法：1234567for (var i = 0; i &lt; 5; i++) &#123; (function(i) &#123; setTimeout(function() &#123; console.log(i); &#125;, i * 1000); &#125;)(i);&#125;//在匿名函数外部加闭包 12345678910111213141516//也可以在匿名函数内部return里边加闭包//@汤姆大叔 版本var data = [];for (var k = 0; k &lt; 3; k++) &#123; data[k] = (function _helper(x) &#123; return function () &#123; alert(x); &#125;; &#125;)(k); // 传入"k"值&#125;// 现在结果是正确的了data[0](); // 0data[1](); // 1data[2](); // 2 其实归根结底是函数声明但没有执行的问题. 以上.]]></content>
  </entry>
  <entry>
    <title><![CDATA[0x06]]></title>
    <url>%2F2017%2F07%2F16%2F0x06%2F</url>
    <content type="text"><![CDATA[Summer Training Day 7.今日休息.[无内容] .骗你的.今天闲得蛋疼就优化了一下我的blog,添加一些功能. 不蒜子访问统计不蒜子统计 如图为主题配置文件,uv为网站访问人数，pv为访问总量，page_pv为文章阅读量但是由于前二者统计数量有误：一辈子都不可能有这么多访问量..估计是busuanzi的问题(也可能是next调用busuanzi的相关问题。于是乎关了这两个只留文章阅读量(应该是点击量，因为刷新次数会上升).突然间就正常了你遭得住？噢原来是hexo d之后才会正常，本地是不行的(之后的评论系统同理) LocalSearch搜索官方文档已经说的很明白了，如果按教程走不行，试一下重新hexo s，hexo clean再hexo g. 友言评论系统参考教程：为next添加友言评论支持其实next自己就配置好了友言相关，所以只需要改主题配置文件的UID就好.一开始部署上去之后未能正常显示，以为是又要切换一次主题录入，结果切换之后也不行。于是打开了审查器发现：原来是https的问题，uyan网站不是https于是被block了点击右上方继续加载可正常加载评论区，但是blog网页会变成unsafe.这个真没办法… p.s.今天插入了许多本地图片，也是我第一次插入本地图片(之前的为在线引用)，正确的写法应该为1![](/img/图片.jpg), 其中第一个斜杠不能少，其前面不能加 “ . ” , 当然 “ .. ” 也不行，绝对路径也不行，具体原因尚不知.img文件夹在source下与_post并列(但是不需要加’..’). 以上.]]></content>
  </entry>
  <entry>
    <title><![CDATA[0x05]]></title>
    <url>%2F2017%2F07%2F14%2F0x05%2F</url>
    <content type="text"><![CDATA[Summer Training Day 6.开会零食电影今日周六，早上大家一起讨论了第三四周关于浏览器新标签页的初步构想，包括收藏，登录注册，daily css等等。之后初步讨论了未来产品方向问题，以及培训结束之后去哪玩的问题。下午看电影等零食快递，恐怖片还是蛮恐怖的。晚上看电影吃零食，电影蛮好看。以上.]]></content>
  </entry>
  <entry>
    <title><![CDATA[0x04]]></title>
    <url>%2F2017%2F07%2F14%2F0x04%2F</url>
    <content type="text"><![CDATA[Summer Training Day 5. git进阶操作小博客响应式布局不得不加的meta Git进阶操作12345678git init # 把本地仓库变成git仓库git checkout # 撤销未add的操作git checkout -b # 创建新分支并切换相当于git branch dev + git checkout dev # 创建+切换git remote # 列出已存在的远程分支git merge dev # 在master分支上合并devgit branch # 查看分支git branch -d # 删除分支 一个小博客的前端实现小小复习了一下CSS选择器12345678/*第一次用这个*/@keyframes move&#123; from&#123;margin-top: -5em;opacity:0;&#125; to&#123;margin-top: 0;opacity:1;&#125;&#125;/*keyframes创建入场动画*/body &#123; animation: move 1s;&#125;/*在body用animation调用*/ 响应式布局不得不加的meta12&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"&gt;&lt;!-- 禁止缩放 --&gt; 以上.]]></content>
  </entry>
  <entry>
    <title><![CDATA[0x03]]></title>
    <url>%2F2017%2F07%2F13%2F0x03%2F</url>
    <content type="text"><![CDATA[Summer Training Day 4. Bootstrap框架MVC与MVVMNative &amp; Hybrid &amp; Web APPIFE Task 8 1.Bootstrap框架.栅格系统主div.12&lt;!-- .container用于固定宽度并支持响应式布局 --&gt;&lt;div class="container"&gt;&lt;/div&gt; 12&lt;!-- .container-fluid适用于100%宽度，占据全部视口(viewport)的容器 --&gt;&lt;div class="container-fluid"&gt;&lt;/div&gt; 若干行，每行内最多十二列.列与列之间间隔用padding;为row设置负margin抵消内部padding;前缀col-;从大到小: -lg,-md,-sm,-xs;原理为媒体查询; 响应式列重置与偏移创建class为clearfix的div;偏移:addclass “col-offset-md-num”; 嵌套与排序1234567891011121314&lt;!-- 嵌套 --&gt;&lt;div class="row"&gt; &lt;div class="col-sm-9"&gt; Level 1: .col-sm-9 &lt;div class="row"&gt; &lt;div class="col-xs-8 col-sm-6"&gt; Level 2: .col-xs-8 .col-sm-6 &lt;/div&gt; &lt;div class="col-xs-4 col-sm-6"&gt; Level 2: .col-xs-4 .col-sm-6 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123456&lt;!-- 排序 --&gt;&lt;!-- 数字代表移动列数，push右移动，pull左移 --&gt;&lt;div class="row"&gt; &lt;div class="col-md-9 col-md-push-3"&gt;.col-md-9 .col-md-push-3&lt;/div&gt; &lt;div class="col-md-3 col-md-pull-9"&gt;.col-md-3 .col-md-pull-9&lt;/div&gt; &lt;/div&gt; 其他class设置为h1-h6可改变内联元素大小;&lt;small&gt;标签或.small类可用于副标题;.lead类可突出段落;&lt;mark&gt;:tohighlight text;&lt;del&gt;:加删除线;&lt;ins&gt;:加下划线;&lt;u&gt;:同上;. 2.MVC与MVVM.MVC: Model View ControllerM是指业务模型，V是指用户界面，C是指控制器MVVM: Model-View-ViewModel 3.三种APPNative App,原生语言Hybrid App,混合Web App;网页.p.s. 其实今天根本没用到bootstrap框架.. 4.IFE Task.Task 8实现栅格布局利用Flex布局 + @media媒体查询完成.12345678&lt;body&gt; &lt;div class="row"&gt; &lt;div class="md-4 sm-6"&gt;&lt;/div&gt; &lt;div class="md-4 sm-6"&gt;&lt;/div&gt; &lt;div class="md-4 sm-12"&gt;&lt;/div&gt; &lt;/div&gt; ...&lt;/body&gt; 12345678910111213141516171819202122body &#123; ...&#125;.row &#123; ...&#125;@media screen and (min-width: 768px)&#123; .md-1 &#123; width: 8.33% ; &#125; ... /*空格很重要，不该丢的不要丢*/&#125; @media screen and (max-width: 768px)&#123; .row &#123; flex-wrap: wrap; &#125; .sm-2 &#123; width: 15.66% ; &#125; ...&#125; 以上.]]></content>
  </entry>
  <entry>
    <title><![CDATA[0x02]]></title>
    <url>%2F2017%2F07%2F12%2F0x02%2F</url>
    <content type="text"><![CDATA[Summer Training Day 3. canvas.Flex.IFE Task 10 1.Canvas.在html创建canvas标签1&lt;canvas width:"600";height:"600"; id="canvas"&gt;&lt;/canvas&gt; js操作.12var canvas = document.getElementById("canvas");//获取canvas.var cxt = canvas.getContext("2d");//上下文.里面有很多绘画方法. 1234cxt.fillStyle = 'rgba';cxt.strokeStyle = 'rgba';cxt.fillRect(x,y,width,height);//填充，以像素计.cxt.strokeRect(x,y,width,height);//描边 画圆.12345cxt.beginPath();cxt.arc(x,y,r,始角度，末角度，boolean);//true为顺时针,false逆时针.cxt.closePath();cxt.fillStyle = 'rgba';cxt.fill();//填充 线条.12345cxt.beginPath();cxt.moveTo(x,y);cxt.lineTo(x,y);cxt.closePath();cxt.stroke(); 清除.1cxt.clearRect(x,y,width,height);//清空矩形区域. 2.Flex 布局阮一峰的日志 123456789body &#123; display: flex; flex-direction: row | row-reverse | column | column-reverse; flex-wrap: nowrap | wrap | wrap-reverse; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;/*前两者之和*/ justify-content: flex-start | flex-end | center | space-between | space-around; align-items: flex-start | flex-end | center | baseline | stretch; align-content/*多根轴线，若只有一则不起作用*/；&#125; H5新特性之LocalStorge.可用于储存客户端临时信息.localStorge储存的数据无时间限制.与之对应的SessionStorge储存的数据当用户关闭窗口时候清空. IFE Task.Task 10Flex 布局 + @media媒体查询.123456&lt;body&gt; &lt;div id="one"&gt;&lt;/div&gt; &lt;div id="two"&gt;&lt;/div&gt; &lt;div id="three"&gt;&lt;/div&gt; &lt;div id="four"&gt;&lt;/div&gt;&lt;/body&gt; 123456789101112131415161718@media screen and (min-width:640px) &#123; body &#123; justify-content: space-between; align-items: center; &#125;&#125;@media screen and (max-width:640px)&#123; body &#123; justify-content: space-between; align-items: flex-start; flex-wrap: wrap; &#125; #four &#123; order: -1; &#125;&#125; 以上.]]></content>
  </entry>
  <entry>
    <title><![CDATA[0x01]]></title>
    <url>%2F2017%2F07%2F11%2F0x01%2F</url>
    <content type="text"><![CDATA[Summer Training Day 2. DOM与BOM.JavaScript的事件机制.IFE Task 2-1 2-2 1.DOM与BOM.ECMAScript（核心）：JavaScript 语言基础；DOM(Document Object Model)文档对象类型：规定了访问HTML和XML的接口；BOM（Browser Object Mode）浏览器对象模型：提供了独立于内容而在浏览器窗口之间进行交互的对象和方法。 ECMAScript不属于任何浏览器;定义了 JavaScript 脚本中最为核心的内容;是 JavaScript 脚本的“骨架”;最新版本是 ES7; BOM定义了 JavaScript 操作浏览器的接口;提供了访问某些功能（如浏览器窗口大小、版本信息、浏览历史记录等）的途径以及操作方法; DOMDOM 定义了 JavaScript 操作 HTML 文档的接口;提供了访问HTML文档的途径以及操作方法;DOM操作html树，包括节点和节点之间的关系；对节点：增删改查；对关系：父子，非父子；child,parent,siblings;获取节点方法：123document.getElementById("");document.getElementsByClassName("");document.getElementsByTagName(""); CSS选择器复习优先级排列：内联样式，id，class，tag； #2.JavaScript的事件机制. 事件冒泡—IE事件流开始由最具体的元素接收，然后逐渐传播到不那么具体的节点;div→body→html→document； 事件捕获—Netscape完全相反. DOM标准事件模型1.事件捕获阶段;2.处于目标阶段;3.事件冒泡阶段;*需要注意的是，1阶段不到body，body被看作是3阶段一部分; 处理事件的两种方法12addEventlistener(event,fn,boolean);removeEventListener(event,fn,boolean); IE事件处理：12attachEvent(event,fn);detachEvent(event,fn); *跨浏览器的事件处理：以后再议; 2.IFE Task2-11234button[0].addEventListener('click',function()&#123; display.innerHTML = input.value;&#125;)#.value 加在值变化之后，不能作用于空值. oninput: 作用于input标签或textarea标签，实时调用js函数;格式：1&lt;input oninput= "myFunction()"&gt;&lt;/input&gt; 2-2新操作.123456789newData.sort(function (a, b) &#123; return b[1] - a[1]; &#125;); # sort # 基本形式是 # object.sort(function(a,b)&#123; # return a-b; # &#125;) # 其中a-b：从小到大排序；b-a：从大到小； 12345678910var number = ["一","二","三","四"]; for (var i = 0; i &lt; newData.length; i++) &#123; var li = document.createElement("li"); var ul = document.getElementById("aqi-list"); ul.appendChild(li); li.innerHTML = "第" + number[i] + "名" + ":" + newData[i][0] + "," + newData[i][1]; console.log(newData[i]); #&lt;li&gt;第一名：福州（样例），10&lt;/li&gt; #&lt;li&gt;第二名：福州（样例），10&lt;/li&gt; &#125; 以上.]]></content>
  </entry>
  <entry>
    <title><![CDATA[0x00]]></title>
    <url>%2F2017%2F07%2F11%2F0x00%2F</url>
    <content type="text"><![CDATA[Summer Training Day 1. 基本命令行操作（git bash）git基本操作Hexo个人博客搭建 基本命令行操作（git bash）12345678910cd(change directory) : cd + 路径cat（查看文件） : cat + 文件名ls(list files) : ls -a(all)，ls -alpwd（print working directory） # 显示当前目录mkdir（make directory) : mkdir + 目录名echo : echo "内容" &gt;&gt; 文件名 # 写入mv(move) : mv "文件名" 路径 # 移动文件rm(remove) : rm "文件名" # 删除文件cp(copy) : cp "文件名" 路径 # 复制文件vim # 打开vim文本编辑器 . git基本操作12345678git clone + 仓库地址git add + 文件名git statusgit resetgit commit -m "" # 一定要有git log # 查看commit信息git push origin mastergit pull origin master . Hexo个人博客搭建a) Prepare1.Download Node.js;2.Download Git;3.Use your id to make respository e.g. : matteokjh.github.io;4.Setting Github Pages as master branch;5.SSH Key:1$ ssh-keygen -t rsa -C "e-mail" open id_rsa.pub and copy tohttps://github.com/settings/ssh remember don’t copy ‘enter’title is not important. b) Hexo1.Install Hexo.123$ npm install -g hexo-cli $ hexo#test 2.Setting.open /blog/_config.yml123456title: Castersubtitle: blogging is the new sexydescription: Valar Morghulisauthor: Caster K.language: zh-Hanstimezone: Asia/Shanghai 1url:https://matteokjh.github.io 1234deploy: type: git repo: https://github.com/matteokjh.github.io.git branch: master 3.edit.123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ hexo new "title" write sth. in /source/post/title.md 4.Release.12345678$ hexo s#check on localhost:4000/$ hexo g#generate#if you cannot hexo d,type this.$ npm install hexo-deployer-git --save$ hexo d #deploy Done.]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F07%2F11%2FHello-World%2F</url>
    <content type="text"><![CDATA[This is the end &amp; the beginning;]]></content>
  </entry>
</search>