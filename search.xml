<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[0x0E]]></title>
    <url>%2F2017%2F07%2F24%2F0x0E%2F</url>
    <content type="text"><![CDATA[Summer Training Day 15. Ajax前端工程化 AjaxAsynchronous JavaScript and XML.异步js与XML XMLHttpRequest对象.Ajax技术的核心XHR对象的构建要利用XMLHttpRequest构造函数.12var xhr = new XMLHttpRequest();//IE7+版本. 用法12//三个参数xhr.open("get","example","false");//类型--URL--是否异步发送 这个代码会启动一个针对example的GET请求.URL相对于执行代码的当前页面(绝对路径也行)调用open()方法并不会真正发送请求，而只是启动一个请求以备发送.如果URL与启动请求的页面有任何差别都会报错. 使用send()发送请求：12xhr.send(null);//一个参数 参数的意思是 要请求主体发送的数据.如果不需要则必须写null. 收到相应后，响应的数据自动填充xhr对象属性.1234responseText: //被返回的文本.responseXML: //若响应的内容类型是 text.xml 或者 application/xml ，这个属性将保存XML DOM文档.status: //响应的HTTP状态.状态码200为正常，304为资源未被修改.statusText: //HTTP状态说明. 检查响应情况.123456789var xhr = new XMLHttpRequest();xhr.open("get","example","false");xhr.send(null);if ( (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; console.log (xhr.responseText);&#125;else &#123; console.log ( "Request was unsuccessful: " + xhr.status );&#125; readyState1234560 : 未初始化(还没调用open()方法)1 : 启动,已经调用open()方法，但未调用send(). 2 : 发送,已经调用send()方法，但未收到响应.3 : 接受,已经接收到部分响应数据.4 : 完成,就能够完全接受响应数据,而且已经可以在客户端使用. 只要readyState属性值变化，都会触发一次readyStatechange事件.123456789101112var xhr = new XMLHttpRequest();xhr.onreadyStatechange = function()&#123; if(xhr.readyState == 4)&#123; if ( (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; console.log (xhr.responseText); &#125;else &#123; console.log ( "Request was unsuccessful: " + xhr.status ); &#125; &#125;&#125;;xhr.open("get","example","false");xhr.send(null); 接收到响应之前可以用abort来取消异步请求，取消之后还要解引用.1xhr.abort(); GET &amp; POST GET 请求(最常见)-从指定资源请求数据--URL最大长度为2048个字符--安全性较差，因为发送的数据是URL一部分且数据对所有人可见--只允许ASCII字符-传入open()方法的URL必须经过正确的编码.每个参数的 name &amp; value 都必须使用encodeURIComponent()进行编码.然后才能放到URL末尾，且所有name-value都必须由 “&amp;” 分隔.123456789xhr.open("get","example.php?name1=value1&amp;value2",true);``` 辅助添加函数：```javascriptfunction addURLParam(url,name,value)&#123; url += (url.indexOf("?") == -1 ? "?" : "&amp;"); url += encodeURIComponent(name) + "=" + encodeURIComponent(value); return url;&#125; 使用：12345678var url = "example.php";//添加参数url = addURLParam(url,"name","Nicholas");//之前全写错了写成Nicolas了.url = addURLParam(url,"book","Professional JavaScript");//初始化请求xhr.open("get",url,false); 使用addURLParam()函数可以确保格式良好. POST 请求-向指定资源提交要被处理的数据-与GET不同，post请求的主体可以包含非常多数据且格式不限.post不会被缓存，不会在浏览器历史记录中.对长度无要求.GET请求的速度最大可以达到POST的两倍. XHR 2. 老版本不足: 1.只支持文本数据的传送，无法用来读取和上传二进制文件。2.传送和接收数据时，没有进度信息，只能提示有没有完成。3.受到”同域限制”（Same Origin Policy），只能向同一域名的服务器请求数据。 新版本特性： 1.可以设置HTTP请求的时限。 (timeout)2.可以使用FormData对象管理表单数据。 (FormData)3.可以上传文件。 ()4.可以请求不同域名下的数据（跨域请求）。 ()5.可以获取服务器端的二进制数据。6.可以获得数据传输的进度信息。 详述.以下摘自:阮一峰:XMLHttpRequest Level 2 使用指南1.timeout. 123456xhr.timeout = 3000; //3秒后自动停止HTTP请求.//与之配对的ontimeout事件.xhr.ontimeout = function(event)&#123; console.log("请求超时！");&#125; 2.FromData. 1234var fromData = new FromData();fromData.append("username","Nicholas");fromData.append("book","Professional JavaScript");xhr.send(fromData); 3.上传文件. 12345var fromData = new FromData();for(i = 0 ; i &lt; files.length ; i++)&#123; fromData.append("files[]",files[i]);&#125;xhr.send(fromData); 4.跨资源共享CORS.(Cross-origin resource sharing). 前提: a)浏览器支持. b)服务器同意.1xhr.open('GET', 'http://other.server/and/path/to/script'); 5.接收二进制数据. 5.1(方法A.改写MIME类型) 原理(from高程) : 返回的MIME类型决定XHR该如何处理它. 基本原理是将服务器返回的非文本数据伪装成文本数据，并告诉浏览器这是用户自定义的字符集.12345678xhr.overrideMimeType("text/plain; charset=x-user-defined");var binStr = xhr.responseText; //用responseText接收二进制数据.//由于此时浏览器把它当作文本数据，所以要一个一个还原.for(var i = 0, len = binStr.length; i&lt; len; i++)&#123; var c = binStr.charCodeAt(i); var byte = c &amp; 0xff;&#125;//最后一行的位运算"c &amp; 0xff"，表示在每个字符的两个字节之中，只保留后一个字节，将前一个字节扔掉。原因是浏览器解读字符的时候，会把字符自动解读成Unicode的0xF700-0xF7ff区段。 5.2(方法B.responseType属性)12345var xhr = new XMLHttpRequest();xhr.open('GET', '/path/to/image.png');xhr.responseType = 'blob';//接收数据的时候用浏览器自带的Blob对象var blob = new Blob([xhr.response],&#123;type: "img/png"&#125;); 用arrayBuffer替代responseType可以把二进制数据存放在数组中,但是接收的时候需要遍历.(详见链接) 6.progress进度条. 12345678xhr.onprogress = updateProgress;xhr.upload.onprogress = updateProgress;function updateProgress(event) &#123; if (event.lengthComputable) &#123; var percentComplete = event.loaded / event.total; &#125;&#125; 与progress相关的还有5个事件，具体看链接. 前端工程化含义:1.持续集成.(git)2.规范化.3.模块化.4.单元和功能测试.5.自动化.以上5点摘自红莲个人理解就是团队效率和个人效率，以前者为主.团队合作一个项目的时候需要建立各自分支之后合并，为了大限度防止冲突，开始的分工很重要，这也涉及到第三点模块化，有点类似C的模块化编程，分功能分模块地编程,能够减少冲突并且使每位成员的时间和精力得到充分利用.团队成员一致地遵守一定的规范会让整体更加干净，增强可读性和可维护性.测试的作用也很显著，每个分部都测试好了，之后合并的问题就不会过分涉及部分模块,而偏向整体或接口.自动化是方便每位程序员提高效率的，每个人效率都提高了团队效率自然就高.总之，工程化是个好东西.在从个人练习向团队项目转化时应该耗费一些精力和时间去学习践行工程化来使得团队得益. 以上.]]></content>
  </entry>
  <entry>
    <title><![CDATA[0 x 0D]]></title>
    <url>%2F2017%2F07%2F24%2F0x0D%2F</url>
    <content type="text"><![CDATA[Summer Training Day 14. 休息日. 真没有内容..弄成折叠的没别的意思,只是相关统计以及评论系统无法在主页加载. 以上.]]></content>
  </entry>
  <entry>
    <title><![CDATA[0x0C]]></title>
    <url>%2F2017%2F07%2F22%2F0x0C%2F</url>
    <content type="text"><![CDATA[Summer Training Day 13. LiveRe 今天早上照例是产品大会.进一步商讨了方案.我针对自己博客的评论系统问题做出了一些改动.之前提到过youyan(友言)评论系统因为没有https证书所以会被浏览器block，要点击右上角加载不安全版本才能正常显示，但是这样就显得我的博客不干不净一样.于是乎，在今天，我决定把它ban掉.直接换一个评论系统.我认准了来必力(LiveRe),一个外国做的评论系统.这个系统有https证书，可以在博客直接加载.而且新版next兼容了livere可以像youyan一样直接输个UID就能用,非常非常方便.以下是教程: 百度livere，进入官网，可以设置语言为中文，方便操作.点击右上角注册，一步一步填写关于你个人网页的信息，设置评论推送，显示分页方式等等.之后就会输出一串js代码：获取如图所示的一串UID，复制到 next 主题配置文件(/theme/next/_config.yml)中的对应位置即可.真的是非常非常简单！另外可以看到，上官网个人信息可以管理自己博客的评论，查看等等..实在是太强大了. 以上.]]></content>
  </entry>
  <entry>
    <title><![CDATA[0x0B]]></title>
    <url>%2F2017%2F07%2F21%2F0x0B%2F</url>
    <content type="text"><![CDATA[Summer Training Day 12. apply&amp;call&amp;bind.json call&amp;apply&amp;bind apply()12345678var x = 0;function test()&#123; alert(this.x);&#125;var o=&#123;&#125;;o.x = 1;o.m = test;o.m.apply(); //0 apply()和call()12function.apply(thisArg, [argsArray])thisArg //传入function内this的值(可以改变this指向thisArg) “thisArg在 fun 函数运行时指定的 this 值。需要注意的是，指定的 this 值并不一定是该函数执行时真正的 this 值，如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动指向全局对象（浏览器中就是window对象），同时值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的自动包装对象。argsArray一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 fun 函数。如果该参数的值为null 或 undefined，则表示不需要传入任何参数。”以上为MDN的解释.其实就是改变this指向，从原来的改为指向thisArg.call和apply类似，不同点在于call第二项需要直接传递给函数，即一项一项写出来，apply可以以一个数组形式写出来. bind()bind会创建一个函数的实例，this值会绑定到传给bind()函数的值.本质上同apply&amp;call但是需要赋给变量. json(Javascript Object Notation.)是一种数据格式而非语言. 语法.可以表示以下三种类型的值. 简单值数字，字符串，布尔值，null(字符串必须使用双引号) 对象JSON无变量，没有变量的概念，所以没有声明变量这一步骤,语句结束也无分号.如：12345678&#123; "name": "Nicolas", "age": 29, "school": &#123; "name": "Merrimack College", "location": "North Andover, MA" &#125;&#125; json中不能写注释. 数组123456789101112131415161718[ &#123; "title": "Professional JavaScript", "authors": [ "Nicolas C. Zakas" ], "edition": 3, "year": 2011 &#125;, &#123; "title": "Professional JavaScript", "authors": [ "Nicolas C. Zakas" ], "edition": 2, "year": 2009 &#125;,] 解析与序列化选项.stringify() 与 parse()前者转化为JSON字符串，后者解析.前者输出的JSON不包含任何空格字符或缩进，因此保存在jsontext中的字符串显示如下：1&#123;"title": "Professional JavaScript","authors": ["Nicolas C. Zakas"],"edition": 3,"year": 2011&#125; 所有函数及原型成员都会被有意忽略，值为undefined的任何属性也会被跳过. 序列化选项第二个参数： 函数1var jsontext = JSON.stringify(book,["title","edition"]); 第三个参数： 缩进和空白符1var jsontext = JSON.stringify(book,null,4); 换行符自动包含，缩进空格数为4;也可以变成：1var jsontext = JSON.stringify(book,null,"--"); 缩进字符串最长不能超过10个，若超过了只显示前10个.可以在js任意对象中添加toJSON()方法，作为函数过滤器的补充.stringify()顺序：1.如果存在toJSON()方法且能通过它取得有效值，则调用该方法，否则返回对象.2.如果提供了第二个参数，应用改函数过滤器.传入函数过滤器的值是第一步返回的值.3.对第2步返回的值进行相应序列化.4.若提供了第三个参数,执行相应格式化. Ajax待续.. 以上.]]></content>
  </entry>
  <entry>
    <title><![CDATA[0x0A]]></title>
    <url>%2F2017%2F07%2F21%2F0x0A%2F</url>
    <content type="text"><![CDATA[Summer Training Day 11. 画钟this clockummmmm..没什么可说的，css设置好html,body，canvas位置关系之后，剩下的就是js.先画底圆，然后刻度，然后秒分时针，最后中间点.计时器setIinterval(function,1000);1秒一次，内部先clear再draw.一开始先draw一次让网页刷新就有东西.具体实现利用了许多数学的东西,简单但麻烦.强烈推荐colorhunt配色网站以及Webgradients渐变色网站 thisthis的四种用法： 直接调用.this指向全局对象.12345 var x = 1; function test()&#123; consloe.log(this.x); &#125; test(); // 1(非严格模式下) this.x就是window.x.改一改：123456 var x = 1; function test()&#123; this.x = 0; &#125; test(); console.log(x); //0,改了全局x. 高难度直接调用：123456789101112var name = "the window";var object = &#123; name : "my object", getNameFunc : function()&#123; return function()&#123; return this.name; &#125;; &#125;&#125;; console.log(object.getNameFunc()()); //"the window"(非严格模式下) 第一个return返回的是函数，即object.getNameFunc()接收的是一个匿名函数( 记object.getNameFunc()为a )，第二个括号a()相当于直接调用.a()里面的this当然是指向全局.若要访问object内部的name.12345678910111213var name = "the window";var object = &#123; name : "my object", getNameFunc : function()&#123; var that = this; //此时this指向object return function()&#123;//这个return匿名函数是全局调用的，但是里面是之前保存的that不是this，故输出my object. return that.name; &#125;; &#125;&#125;; //另外，在构建闭包(匿名函数)全局调用getNameFunc的时候访问了内部变量that，此时that仍然引用着object.console.log(object.getNameFunc()()); //"my object" 或者更简单地：123456789101112var name = "the window";var object = &#123; name : "my object", getNameFunc : function()&#123; return this.name;//毫无悬念地指向object &#125;&#125;; console.log(object.getNameFunc()); //"my object"(object.getNameFunc = object.getNameFunc)(); //"the window"//为什么这里又输出the window？原因是这是赋值表达式，赋值后是函数本身，相当于a()，全局调用. 方法调用.作为对象方法调用.12345678function test()&#123; console.log(this.x);&#125;var o = &#123;&#125;;o.x = 1;o.m = test;o.m(); // 1//这里m变成test方法. call,apply,bind显而易见地改变了this的值指向新值. new使用new的具体步骤中有改变this指向空对象这一步. 以上.]]></content>
  </entry>
  <entry>
    <title><![CDATA[0x09]]></title>
    <url>%2F2017%2F07%2F19%2F0x09%2F</url>
    <content type="text"><![CDATA[Summer Training Day 10.构造函数与原型.继承.今天补充前两天的内容. 构造函数与原型构造函数模式.1234567891011//构造函数默认以大写字母开头.function Person(name, age)&#123; this.name = name; this.age = age; this.sayName = function()&#123; alert(this.name); &#125;;&#125;var person1 = new Person("Nicolas",29);var person2 = new Person("John",18);//可以说，使用new操作符来创建新对象的函数就可以作为构造函数. 要创建新实例，则必须使用new操作符.new做了5件事情：1.创建新对象.2.this指向这个新对象(通过把构造函数的作用域赋于新对象).3.连接原型链.4.执行函数(也是在给新对象添加属性).5.返回新对象.(Object与Array为原生构造函数) 纯构造函数的缺点.每个方法要在每个实例上创建一遍，因此，不同实例上的同名函数其实是不相等的.与其在构造函数内部定义函数，还不如在外部定义，这样每个实例共享一个函数，但是这样做又有问题.在全局作用域定义函数但是只是让某个对象使用就有点浪费，而且可能需要为此定义许多全局函数.这个自定义引用类型就毫无封装性可言了.以上问题可以通过原型模式解决. 原型模式.每个函数都有一个prototype(原型)属性，该属性为一个指针指向一个对象(原型对象)，这个对象包含特定类型所有实例共享的属性和方法.使用原型对象可以让所有实例共享它所包含的属性和方法.就不必要在构造函数中定义.123456789101112131415function Person()&#123;&#125;Person.prototype.name = "Nicolas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function()&#123; console.log(this.name);&#125;;var person1 = new Person();person1.sayName(); //"Nicolas"var person2 = new Person();person2.sayName(); //"Nicolas"console.log(person1.sayName === person2.sayName); //True 默认情况下，所有原型对象会自动获得一个constructor(构造函数)属性.此属性为一个指向prototype属性所在函数(即构造函数)的指针.即：Person.prototype.constructor = Person;创建了构造函数后，其原型对象默认只会取得constructor属性，其他属性继承Object;创建新实例后，该实例内部包含一个指针(内部属性)__proto__,指向构造函数的原型对象,该属性对脚本完全不可视.[需要注意的是，此关系(Person与Person.prototype)存在于构造函数与其原型对象之间，而与实例无关(即person1无prototype属性只有看不见的__proto__)].但是实例对象共享constructor属性(可能是因为__proto__属性吧).person1.constructor == Person.虽然__proto__属性无法访问，但的确是可以通过 isPrototypeOf() 方法来确定这个关系.若__proto__指向Person.prototype，则会返回True.12console.log(Person.prototype.isPrototypeOf(person1)); //Trueconsole.log(Person.prototype.isPrototypeOf(person2)); //True 也可以通过Object.getPrototypeOf()方法返回__proto__的值.12console.log(Object.getPrototypeOf(person1) == Person.prototype); //Trueconsole.log(Object.getPrototypeOf(person1).name); //"Nicolas" 每当代码读取某个对象的某个属性时，都会执行一次搜索.首先从实例开始,如果没找到,则继续搜索其指针指向的原型对象.有的话就返回其属性值.也就是说，当我们调用person1.sayName()时，会先后进行两次搜索.如果在实例找到就不会往上找.这样就引出了在实例不能重写原型属性，但在属性同名的情况下会屏蔽原型属性的问题.12345678910111213141516function Person()&#123;&#125;Person.prototype.name = "Nicolas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function()&#123; console.log(this.name);&#125;;var person1 = new Person();var person2 = new Person();person1.name = "Greg"; //此操作相当于在实例中新建name属性并且屏蔽Person.prototype中的name.console.log(person1.name); //"Greg"console.log(person2.name); //"Nicolas" 即便 person1.name = “”; 也不能恢复对原型Person.name的链接.要想恢复连接，就要用到delete操作符.1delete person1.name; hasOwnProperty()方法可以检测一个属性是在原型中还是实例中123456789101112131415161718function Person()&#123;&#125;Person.prototype.name = "Nicolas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function()&#123; console.log(this.name);&#125;;var person1 = new Person();var person2 = new Person();console.log(person1.hasOwnProperty("name")); //falseperson1.name = "Greg";console.log(person1.name); //Greg————来自实例console.log(person1.hasOwnProperty("name")); //true Object.getOwnPropertyDescriptor( object , propertyname )方法只能用于实例属性信息获取.1234console.log(Object.getOwnPropertyDescriptor(person1,"name"));//Object &#123;value: "Greg", writable: true, enumerable: true, configurable: true&#125;console.log(Object.getOwnPropertyDescriptor(person2,"name"));//undefined.因为person2中未创建name属性.原型的属性它不会找. in操作符单独使用时，会在能够访问给定属性时返回true，无论该属性存在于原型中还是实例中.1console.log("name" in person1); //true Object.keys()方法获取对象上所有可枚举的实例属性.1234567var keys = Object.keys(Person.prototype);console.log(keys); //"name,age,job,sayName"var p1 = new Person();p1.name = "Rob";p1.age = 31;var p1keys = Object.keys(p1);console.log(p1keys); //"name,age" 定义原型对象属性的简便写法：123456789function Person ()&#123;&#125;Person.prototype = &#123; name : "Nicolas", age : 29, job : "Software Engineer", sayName : function()&#123; console.log(this.name); &#125;&#125;;//注意冒号和逗号 此方法有个缺陷，就是constructor不再指向Person而是Object(本质上改写了整个prototype),要指回来需要在花括号里面加上”constructor : Person”:12345678910function Person ()&#123;&#125;Person.prototype = &#123; constructor : Person name : "Nicolas", age : 29, job : "Software Engineer", sayName : function()&#123; console.log(this.name); &#125;&#125;; 但是这样做又有一个问题，就是其[[Enumerable]]属性被设置为true,即 可枚举.若不想让constructor可枚举，则可以换一种添加方法.Object.defineProperty(object,property,descriptor)1234Object.defineProperty(Person.prototype,"constructor",&#123; enumerable : false, value : Person&#125;); 继承原型链本质上是把父类型的实例赋予子类型的原型对象.重写原型对象，代之以一个新类型的实例.12345678910111213141516171819function SuperType () &#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function()&#123; return this.property;&#125;function SubType()&#123; this.subproperty = false;&#125;//继承 SuperTypeSubType.prototype = new SuperType();SubType.prototype.getSubValue = function()&#123; return this.subproperty;&#125;;var instance = new SubType();console.log(instance.getSuperValue()); //true 相关继承方式(原型式，寄生式，寄生组合式)以后再议… 以上抄书.]]></content>
  </entry>
  <entry>
    <title><![CDATA[0x08]]></title>
    <url>%2F2017%2F07%2F18%2F0x08%2F</url>
    <content type="text"><![CDATA[Summer Training Day 9. 引用类型 引用类型 Object类型创建方法：123//new操作符法.var person = new Object(); &lt;=&gt; var person = &#123;&#125;;//Object()为构造函数. 12345678910111213//对象字面量法var person = &#123; name : "John", age : 30&#125;;//其中大括号表示对象字面量的开始，出现在表达式上下文中，//表示一个表达式的开始.如果出现在语句上下文就表示语句的开始.//其中属性名也可以用引号引起来，但是这样会导致其他数值也会自动转成字符串.var person = &#123; "name" : "John", "age" : 30 5 : true//这里的5会转换成字符串&#125;; 12345678910//点表示法.（一般方法）person.nameperson.age//方括号表示法.alert (person["name"]);//可以通过变量访问属性.var propertyName = "name";//这里把属性赋给变量alert (person[propertyName]);//John//另外，在一些情况下不得不用方括号.person["first name"] = "John"//这里有空格用点表示会有歧义. Array类型创建方法：1234var colors = new Array(); &lt;=&gt; var colors = [];var colors = new Array(20);//length = 20;var colors = new Array("grey");//值为grey.var colors = new Array("grey","red","blue"); 数组的length属性不是只读的，可以移除或新增项.1234567var color = ["grey","red","blue"];color.length = 2;//blue被删除.color.length = 4;alert(color[3]);//undefined.//还可以实现类似push的功能.var color = ["grey","red","blue"];colors[colors.length] = "black";//末尾新增black. p.s.数组最多可以包含4 294 967 295项.检测数组：1234567var colors = [];colors instanceOf Array;//True.//但是instanceOf有缺陷，它假定只有一个全局执行环境.//当网页有多个框架时就会有多个不同的全局执行环境.//为了解决这个问题，ES5新增了Array.isArray(value)方法.Array.isArray(colors);//True.//此方法不管value在哪里创建的，就返回value是不是数组. 一些方法.栈方法.LIFO后进先出 push()&amp;pop();12345678var colors = [];//创建数组var count = colors.push("red","white");//推入两项alert(count);//2var count = colors.push("black");//推入另一项var item = colors.pop();//弹出最后一项并取之.alert(item);//"black"alert(colors.length);//2 队列方法.FIFO先进先出 push()&amp;shift()&amp;unshift();12345678var colors = [];//创建数组var count = colors.push("red","white");//推入两项alert(count);//2var count = colors.push("black");//推入另一项var item = colors.shift();//弹出第一项并取之.alert(item);//"red"alert(colors.length);//2 12//与shift()相反的unshift()即是在第一项前面添加新项.//unshift也与push对应. 操作方法. concat() 123456789//concat.var colors = ["red","green","blue"];var colors2 = colors.concat("yellow",["black","brown"]);alert(color)//red,green,bluealert(color2)//red,green,blue,yellow,black,brown//若concat()无参数则只是复制当前数组并返回副本//若有一个或多个一维数组，则将它们每一项都添加进副本返回.//数组嵌套(n维数组)的情况，内层的作为一个n-1维数组返回.//若就一个数组则正常添加并返回. slice() 12345678910111213var colors = ["red","green","blue","yellow","purple"];var colors2 = colors.slice(1);var colors3 = colors.slice(1,4);//若只有一个参数则返回从指定参数开始到数组末尾所有项.//若两个参数则返回起始位置到终止位置所有项但不包含终止位置项(左闭右开)"[ , )"alert(colors2);//green,blue,yellow,purplealert(colors3);//green,blue,yellow//当第二个参数为负数时，情况又有所不同.var colors4 = colors.slice(1,-1);//应该输出green,blue,yellow//负数是从右边数起的，正确理解应该是 -1 + 5 = 4// 负值 + arr.length//即colors.slice(1,-1); &lt;=&gt; colors.slice(1,4); p.s.若起始位置大于终止位置(负值除外)，则返回空数组。 spilce()据《JavaScript高级程序设计(第三版)》一书，splice()方法”算是最强大的数组方法”12345Array.splice(position,deleteNumber,addThings);position//表示操作点位置.这个位置指向的是两个相邻项之间的空隙.deleteNumber//表示从操作点位置开始删除项的个数.addThings//表示从操作点开始插入的新项.该方法返回的是被删除的数组,若没有删除则返回空数组. 如：123456789101112var colors = ["red","green","blue"];var removed = colors.splice(0,1);//从0位置开始删一项redalert(colors);//green,bluealert(removed);//redvar removed = colors.splice(1,0,"yellow","orange");//从1位置开始不删除并插入两新项alert(colors);//green,yellow,orange,bluealert(removed);//空var removed = colors.splice(1,1,"red","purple");//从1位置开始删除yellow并插入两新项alert(colors);//green,red,purple,orange,bluealert(removed);//yellow 现在看来果不其然.. 迭代方法.以下方法均为对数组，每一项执行给定的函数.且均不会改变原数组的值. every(): 若每一项都返回True，则返回True. some(): 任意一项返回True,则返回True. filter(): 返回所有返回True的项构成的数组. forEach(): 无返回值. map(): 返回每次函数调用的结果构成的数组. 格式(以forEach为例)：123num.forEach(function(item,index.array)&#123; //操作.&#125;); 归并方法. reduce()&amp;reduceRight()12345678//reduce()从第一项开始逐项遍历到最后.//reduceRight()从最后一项开始遍历.//两者都是返回一个数值.格式:var values = [1,2,3,4,5];var sum = values.reduce(function(accumulate,current,index,array)&#123; return accumulate + current;&#125;); Date类型1234var now = new Date();console.log(date);//当前时间;getHours();//Minutes,Seconds,Month,FullYearsetHours(); 以上.]]></content>
  </entry>
  <entry>
    <title><![CDATA[0x07]]></title>
    <url>%2F2017%2F07%2F17%2F0x07%2F</url>
    <content type="text"><![CDATA[Summer Training Day 8. IFE Task 15异步，作用域与闭包第二周的第一天. IFE Task. Task 15.;12345innerText//除去html标签外的内容.split//split("",num)方法用于把一个字符串分割成字符串数组.左参数为分割标准，右参数为长度(可选).childnodes//我们平时用document.getElementById("")获取的是元素节点，非文本节点，childnodes获取的即是元素节点的子节点(包括文本).nodeValue//获取节点值push//push方法在数组末尾添加一个或多个元素，并返回新长度(注意是长度数值而非返回新数组). 12345getData();//获取sort();//排序render();//显示btnhandle();//绑定按钮init();//执行 最后加一句防止按钮重复点击：1if(resort.innerText == "") 异步、作用域与闭包. 执行环境与作用域1.执行环境(execution context,简称环境)，每个环境都有与之对应的一个变量对象(variable object)，包含在环境中定义的所有变量和函数。全局执行环境，是最外围的执行环境，在Web中被认为是windows对象。某个执行环境中的代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁，但在全局执行环境的直到应用程序退出才会被销毁。2.每个函数都有自己的执行环境，当执行流进入一个函数，函数的环境会被推入一个环境栈中，执行完之后栈将其环境弹出，把控制权交还给之前的执行环境。3.当代码在一个环境中执行时，会创建变量对象的一个作用域链(scope chain)。其前端始终是当前执行的代码所在环境的变量对象。如果是函数，则其活动对象(activation object)为变量对象。活动对象最开始时只包含argument对象(此对象在全局是不存在的)，全局执行环境的变量始终是作用域链的最后一个对象。(摘自JavaScript高级程序设计) 闭包定义：闭包是指有权访问另一个函数作用域中的变量的函数。在函数内部创建另一个函数就是一种创建闭包。攻略↓Excuse me？这个前端88面试在搞事！汤姆大叔的博客:”深入理解JavaScript系列（16）：闭包（Closures）”所以，不只是setTimeout的问题. 12345for (var i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 1000 * i);&#125; //输出5个5 与 1234567891011var data = [];for (var k = 0; k &lt; 3; k++) &#123; data[k] = function () &#123; alert(k); &#125;;&#125;data[0](); // 3, 而不是0data[1](); // 3, 而不是1data[2](); // 3, 而不是2//上下文共用一个[[scope]]属性，故k改变 解决方法：1234567for (var i = 0; i &lt; 5; i++) &#123; (function(i) &#123; setTimeout(function() &#123; console.log(i); &#125;, i * 1000); &#125;)(i);&#125;//在匿名函数外部加闭包 12345678910111213141516//也可以在匿名函数内部return里边加闭包//@汤姆大叔 版本var data = [];for (var k = 0; k &lt; 3; k++) &#123; data[k] = (function _helper(x) &#123; return function () &#123; alert(x); &#125;; &#125;)(k); // 传入"k"值&#125;// 现在结果是正确的了data[0](); // 0data[1](); // 1data[2](); // 2 其实归根结底是函数声明但没有执行的问题. 以上.]]></content>
  </entry>
  <entry>
    <title><![CDATA[0x06]]></title>
    <url>%2F2017%2F07%2F16%2F0x06%2F</url>
    <content type="text"><![CDATA[Summer Training Day 7.今日休息.[无内容] .骗你的.今天闲得蛋疼就优化了一下我的blog,添加一些功能. 不蒜子访问统计不蒜子统计 如图为主题配置文件,uv为网站访问人数，pv为访问总量，page_pv为文章阅读量但是由于前二者统计数量有误：一辈子都不可能有这么多访问量..估计是busuanzi的问题(也可能是next调用busuanzi的相关问题。于是乎关了这两个只留文章阅读量(应该是点击量，因为刷新次数会上升).突然间就正常了你遭得住？噢原来是hexo d之后才会正常，本地是不行的(之后的评论系统同理) LocalSearch搜索官方文档已经说的很明白了，如果按教程走不行，试一下重新hexo s，hexo clean再hexo g. 友言评论系统参考教程：为next添加友言评论支持其实next自己就配置好了友言相关，所以只需要改主题配置文件的UID就好.一开始部署上去之后未能正常显示，以为是又要切换一次主题录入，结果切换之后也不行。于是打开了审查器发现：原来是https的问题，uyan网站不是https于是被block了点击右上方继续加载可正常加载评论区，但是blog网页会变成unsafe.这个真没办法… p.s.今天插入了许多本地图片，也是我第一次插入本地图片(之前的为在线引用)，正确的写法应该为1![](/img/图片.jpg), 其中第一个斜杠不能少，其前面不能加 “ . ” , 当然 “ .. ” 也不行，绝对路径也不行，具体原因尚不知.img文件夹在source下与_post并列(但是不需要加’..’). 以上.]]></content>
  </entry>
  <entry>
    <title><![CDATA[0x05]]></title>
    <url>%2F2017%2F07%2F14%2F0x05%2F</url>
    <content type="text"><![CDATA[Summer Training Day 6.开会零食电影今日周六，早上大家一起讨论了第三四周关于浏览器新标签页的初步构想，包括收藏，登录注册，daily css等等。之后初步讨论了未来产品方向问题，以及培训结束之后去哪玩的问题。下午看电影等零食快递，恐怖片还是蛮恐怖的。晚上看电影吃零食，电影蛮好看。以上.]]></content>
  </entry>
  <entry>
    <title><![CDATA[0x04]]></title>
    <url>%2F2017%2F07%2F14%2F0x04%2F</url>
    <content type="text"><![CDATA[Summer Training Day 5. git进阶操作小博客响应式布局不得不加的meta Git进阶操作12345678git init # 把本地仓库变成git仓库git checkout # 撤销未add的操作git checkout -b # 创建新分支并切换相当于git branch dev + git checkout dev # 创建+切换git remote # 列出已存在的远程分支git merge dev # 在master分支上合并devgit branch # 查看分支git branch -d # 删除分支 一个小博客的前端实现小小复习了一下CSS选择器12345678/*第一次用这个*/@keyframes move&#123; from&#123;margin-top: -5em;opacity:0;&#125; to&#123;margin-top: 0;opacity:1;&#125;&#125;/*keyframes创建入场动画*/body &#123; animation: move 1s;&#125;/*在body用animation调用*/ 响应式布局不得不加的meta12&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"&gt;&lt;!-- 禁止缩放 --&gt; 以上.]]></content>
  </entry>
  <entry>
    <title><![CDATA[0x03]]></title>
    <url>%2F2017%2F07%2F13%2F0x03%2F</url>
    <content type="text"><![CDATA[Summer Training Day 4. Bootstrap框架MVC与MVVMNative &amp; Hybrid &amp; Web APPIFE Task 8 1.Bootstrap框架.栅格系统主div.12&lt;!-- .container用于固定宽度并支持响应式布局 --&gt;&lt;div class="container"&gt;&lt;/div&gt; 12&lt;!-- .container-fluid适用于100%宽度，占据全部视口(viewport)的容器 --&gt;&lt;div class="container-fluid"&gt;&lt;/div&gt; 若干行，每行内最多十二列.列与列之间间隔用padding;为row设置负margin抵消内部padding;前缀col-;从大到小: -lg,-md,-sm,-xs;原理为媒体查询; 响应式列重置与偏移创建class为clearfix的div;偏移:addclass “col-offset-md-num”; 嵌套与排序1234567891011121314&lt;!-- 嵌套 --&gt;&lt;div class="row"&gt; &lt;div class="col-sm-9"&gt; Level 1: .col-sm-9 &lt;div class="row"&gt; &lt;div class="col-xs-8 col-sm-6"&gt; Level 2: .col-xs-8 .col-sm-6 &lt;/div&gt; &lt;div class="col-xs-4 col-sm-6"&gt; Level 2: .col-xs-4 .col-sm-6 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123456&lt;!-- 排序 --&gt;&lt;!-- 数字代表移动列数，push右移动，pull左移 --&gt;&lt;div class="row"&gt; &lt;div class="col-md-9 col-md-push-3"&gt;.col-md-9 .col-md-push-3&lt;/div&gt; &lt;div class="col-md-3 col-md-pull-9"&gt;.col-md-3 .col-md-pull-9&lt;/div&gt; &lt;/div&gt; 其他class设置为h1-h6可改变内联元素大小;&lt;small&gt;标签或.small类可用于副标题;.lead类可突出段落;&lt;mark&gt;:tohighlight text;&lt;del&gt;:加删除线;&lt;ins&gt;:加下划线;&lt;u&gt;:同上;. 2.MVC与MVVM.MVC: Model View ControllerM是指业务模型，V是指用户界面，C是指控制器MVVM: Model-View-ViewModel 3.三种APPNative App,原生语言Hybrid App,混合Web App;网页.p.s. 其实今天根本没用到bootstrap框架.. 4.IFE Task.Task 8实现栅格布局利用Flex布局 + @media媒体查询完成.12345678&lt;body&gt; &lt;div class="row"&gt; &lt;div class="md-4 sm-6"&gt;&lt;/div&gt; &lt;div class="md-4 sm-6"&gt;&lt;/div&gt; &lt;div class="md-4 sm-12"&gt;&lt;/div&gt; &lt;/div&gt; ...&lt;/body&gt; 12345678910111213141516171819202122body &#123; ...&#125;.row &#123; ...&#125;@media screen and (min-width: 768px)&#123; .md-1 &#123; width: 8.33% ; &#125; ... /*空格很重要，不该丢的不要丢*/&#125; @media screen and (max-width: 768px)&#123; .row &#123; flex-wrap: wrap; &#125; .sm-2 &#123; width: 15.66% ; &#125; ...&#125; 以上.]]></content>
  </entry>
  <entry>
    <title><![CDATA[0x02]]></title>
    <url>%2F2017%2F07%2F12%2F0x02%2F</url>
    <content type="text"><![CDATA[Summer Training Day 3. canvas.Flex.IFE Task 10 1.Canvas.在html创建canvas标签1&lt;canvas width:"600";height:"600"; id="canvas"&gt;&lt;/canvas&gt; js操作.12var canvas = document.getElementById("canvas");//获取canvas.var cxt = canvas.getContext("2d");//上下文.里面有很多绘画方法. 1234cxt.fillStyle = 'rgba';cxt.strokeStyle = 'rgba';cxt.fillRect(x,y,width,height);//填充，以像素计.cxt.strokeRect(x,y,width,height);//描边 画圆.12345cxt.beginPath();cxt.arc(x,y,r,始角度，末角度，boolean);//true为顺时针,false逆时针.cxt.closePath();cxt.fillStyle = 'rgba';cxt.fill();//填充 线条.12345cxt.beginPath();cxt.moveTo(x,y);cxt.lineTo(x,y);cxt.closePath();cxt.stroke(); 清除.1cxt.clearRect(x,y,width,height);//清空矩形区域. 2.Flex 布局阮一峰的日志 123456789body &#123; display: flex; flex-direction: row | row-reverse | column | column-reverse; flex-wrap: nowrap | wrap | wrap-reverse; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;/*前两者之和*/ justify-content: flex-start | flex-end | center | space-between | space-around; align-items: flex-start | flex-end | center | baseline | stretch; align-content/*多根轴线，若只有一则不起作用*/；&#125; H5新特性之LocalStorge.可用于储存客户端临时信息.localStorge储存的数据无时间限制.与之对应的SessionStorge储存的数据当用户关闭窗口时候清空. IFE Task.Task 10Flex 布局 + @media媒体查询.123456&lt;body&gt; &lt;div id="one"&gt;&lt;/div&gt; &lt;div id="two"&gt;&lt;/div&gt; &lt;div id="three"&gt;&lt;/div&gt; &lt;div id="four"&gt;&lt;/div&gt;&lt;/body&gt; 123456789101112131415161718@media screen and (min-width:640px) &#123; body &#123; justify-content: space-between; align-items: center; &#125;&#125;@media screen and (max-width:640px)&#123; body &#123; justify-content: space-between; align-items: flex-start; flex-wrap: wrap; &#125; #four &#123; order: -1; &#125;&#125; 以上.]]></content>
  </entry>
  <entry>
    <title><![CDATA[0x01]]></title>
    <url>%2F2017%2F07%2F11%2F0x01%2F</url>
    <content type="text"><![CDATA[Summer Training Day 2. DOM与BOM.JavaScript的事件机制.IFE Task 2-1 2-2 1.DOM与BOM.ECMAScript（核心）：JavaScript 语言基础；DOM(Document Object Model)文档对象类型：规定了访问HTML和XML的接口；BOM（Browser Object Mode）浏览器对象模型：提供了独立于内容而在浏览器窗口之间进行交互的对象和方法。 ECMAScript不属于任何浏览器;定义了 JavaScript 脚本中最为核心的内容;是 JavaScript 脚本的“骨架”;最新版本是 ES7; BOM定义了 JavaScript 操作浏览器的接口;提供了访问某些功能（如浏览器窗口大小、版本信息、浏览历史记录等）的途径以及操作方法; DOMDOM 定义了 JavaScript 操作 HTML 文档的接口;提供了访问HTML文档的途径以及操作方法;DOM操作html树，包括节点和节点之间的关系；对节点：增删改查；对关系：父子，非父子；child,parent,siblings;获取节点方法：123document.getElementById("");document.getElementsByClassName("");document.getElementsByTagName(""); CSS选择器复习优先级排列：内联样式，id，class，tag； #2.JavaScript的事件机制. 事件冒泡—IE事件流开始由最具体的元素接收，然后逐渐传播到不那么具体的节点;div→body→html→document； 事件捕获—Netscape完全相反. DOM标准事件模型1.事件捕获阶段;2.处于目标阶段;3.事件冒泡阶段;*需要注意的是，1阶段不到body，body被看作是3阶段一部分; 处理事件的两种方法12addEventlistener(event,fn,boolean);removeEventListener(event,fn,boolean); IE事件处理：12attachEvent(event,fn);detachEvent(event,fn); *跨浏览器的事件处理：以后再议; 2.IFE Task2-11234button[0].addEventListener('click',function()&#123; display.innerHTML = input.value;&#125;)#.value 加在值变化之后，不能作用于空值. oninput: 作用于input标签或textarea标签，实时调用js函数;格式：1&lt;input oninput= "myFunction()"&gt;&lt;/input&gt; 2-2新操作.123456789newData.sort(function (a, b) &#123; return b[1] - a[1]; &#125;); # sort # 基本形式是 # object.sort(function(a,b)&#123; # return a-b; # &#125;) # 其中a-b：从小到大排序；b-a：从大到小； 12345678910var number = ["一","二","三","四"]; for (var i = 0; i &lt; newData.length; i++) &#123; var li = document.createElement("li"); var ul = document.getElementById("aqi-list"); ul.appendChild(li); li.innerHTML = "第" + number[i] + "名" + ":" + newData[i][0] + "," + newData[i][1]; console.log(newData[i]); #&lt;li&gt;第一名：福州（样例），10&lt;/li&gt; #&lt;li&gt;第二名：福州（样例），10&lt;/li&gt; &#125; 以上.]]></content>
  </entry>
  <entry>
    <title><![CDATA[0x00]]></title>
    <url>%2F2017%2F07%2F11%2F0x00%2F</url>
    <content type="text"><![CDATA[Summer Training Day 1. 基本命令行操作（git bash）git基本操作Hexo个人博客搭建 基本命令行操作（git bash）12345678910cd(change directory) : cd + 路径cat（查看文件） : cat + 文件名ls(list files) : ls -a(all)，ls -alpwd（print working directory） # 显示当前目录mkdir（make directory) : mkdir + 目录名echo : echo "内容" &gt;&gt; 文件名 # 写入mv(move) : mv "文件名" 路径 # 移动文件rm(remove) : rm "文件名" # 删除文件cp(copy) : cp "文件名" 路径 # 复制文件vim # 打开vim文本编辑器 . git基本操作12345678git clone + 仓库地址git add + 文件名git statusgit resetgit commit -m "" # 一定要有git log # 查看commit信息git push origin mastergit pull origin master . Hexo个人博客搭建a) Prepare1.Download Node.js;2.Download Git;3.Use your id to make respository e.g. : matteokjh.github.io;4.Setting Github Pages as master branch;5.SSH Key:1$ ssh-keygen -t rsa -C "e-mail" open id_rsa.pub and copy tohttps://github.com/settings/ssh remember don’t copy ‘enter’title is not important. b) Hexo1.Install Hexo.123$ npm install -g hexo-cli $ hexo#test 2.Setting.open /blog/_config.yml123456title: Castersubtitle: blogging is the new sexydescription: Valar Morghulisauthor: Caster K.language: zh-Hanstimezone: Asia/Shanghai 1url:https://matteokjh.github.io 1234deploy: type: git repo: https://github.com/matteokjh.github.io.git branch: master 3.edit.123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ hexo new "title" write sth. in /source/post/title.md 4.Release.12345678$ hexo s#check on localhost:4000/$ hexo g#generate#if you cannot hexo d,type this.$ npm install hexo-deployer-git --save$ hexo d #deploy Done.]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F07%2F11%2FHello-World%2F</url>
    <content type="text"><![CDATA[This is the end &amp; the beginning;]]></content>
  </entry>
</search>